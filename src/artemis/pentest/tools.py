"""
Security Tools Integration for Artemis Pentest Module

Integrates external security tools:
- nmap: Network/service scanning
- subfinder: Subdomain enumeration
- httpx: HTTP probing and fingerprinting
- katana: Web crawling
- ffuf: Web fuzzing
- gobuster: Directory/DNS bruteforce
- sqlmap: SQL injection testing
- playwright: Browser automation

Each tool is wrapped with:
- Availability detection
- Async execution
- Output parsing
- Error handling
"""

import asyncio
import json
import logging
import os
import shutil
import subprocess
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Optional
from urllib.parse import urlparse

logger = logging.getLogger("artemis.pentest.tools")


@dataclass
class ToolResult:
    """Result from a tool execution."""
    tool: str
    success: bool
    output: str = ""
    parsed: Optional[dict] = None
    error: Optional[str] = None
    duration_ms: int = 0


class SecurityTools:
    """
    Manages external security tools for the pentest pipeline.
    
    Automatically detects available tools and provides async wrappers.
    """
    
    # Tool paths - auto-detected or can be overridden
    TOOL_PATHS = {
        "nmap": None,
        "subfinder": None,
        "httpx": None,
        "katana": None,
        "ffuf": None,
        "gobuster": None,
        "sqlmap": None,
    }
    
    def __init__(self):
        self._available_tools: dict[str, bool] = {}
        self._tool_versions: dict[str, str] = {}
        self._detect_tools()
    
    def _detect_tools(self):
        """Detect available tools and their paths."""
        # Add Go bin to search path
        go_bin = Path.home() / "go" / "bin"
        nmap_path = Path("C:/Program Files (x86)/Nmap")
        
        search_paths = os.environ.get("PATH", "").split(os.pathsep)
        if go_bin.exists():
            search_paths.append(str(go_bin))
        if nmap_path.exists():
            search_paths.append(str(nmap_path))
        
        for tool in self.TOOL_PATHS:
            # Check if tool is in PATH
            tool_exe = f"{tool}.exe" if os.name == "nt" else tool
            path = shutil.which(tool_exe, path=os.pathsep.join(search_paths))
            
            if path:
                self.TOOL_PATHS[tool] = path
                self._available_tools[tool] = True
                logger.info(f"Found {tool}: {path}")
            else:
                self._available_tools[tool] = False
                logger.debug(f"{tool} not found")
    
    def is_available(self, tool: str) -> bool:
        """Check if a tool is available."""
        return self._available_tools.get(tool, False)
    
    def get_available_tools(self) -> list[str]:
        """Get list of available tools."""
        return [t for t, available in self._available_tools.items() if available]
    
    async def _run_tool(
        self,
        tool: str,
        args: list[str],
        timeout: int = 300,
        parse_json: bool = False,
    ) -> ToolResult:
        """Run a tool asynchronously."""
        import time
        
        if not self.is_available(tool):
            return ToolResult(
                tool=tool,
                success=False,
                error=f"{tool} not available",
            )
        
        tool_path = self.TOOL_PATHS[tool]
        cmd = [tool_path] + args
        
        start = time.time()
        
        try:
            result = await asyncio.get_event_loop().run_in_executor(
                None,
                lambda: subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                )
            )
            
            duration_ms = int((time.time() - start) * 1000)
            output = result.stdout or result.stderr
            
            parsed = None
            if parse_json and output:
                try:
                    # Try to parse JSON output
                    parsed = json.loads(output)
                except json.JSONDecodeError:
                    # Try to parse line-by-line JSON
                    lines = [l for l in output.strip().split("\n") if l.strip()]
                    parsed = []
                    for line in lines:
                        try:
                            parsed.append(json.loads(line))
                        except json.JSONDecodeError:
                            pass
            
            return ToolResult(
                tool=tool,
                success=result.returncode == 0,
                output=output,
                parsed=parsed,
                duration_ms=duration_ms,
            )
            
        except subprocess.TimeoutExpired:
            return ToolResult(
                tool=tool,
                success=False,
                error=f"Timeout after {timeout}s",
            )
        except Exception as e:
            return ToolResult(
                tool=tool,
                success=False,
                error=str(e),
            )
    
    # =========================================================================
    # NMAP - Network Scanning
    # =========================================================================
    
    async def nmap_scan(
        self,
        target: str,
        ports: str = "1-1000",
        scripts: Optional[list[str]] = None,
        service_detection: bool = True,
        timeout: int = 300,
    ) -> ToolResult:
        """
        Run nmap scan.
        
        Args:
            target: IP or hostname
            ports: Port range (e.g., "1-1000", "80,443,8080")
            scripts: NSE scripts to run
            service_detection: Enable service/version detection
            timeout: Timeout in seconds
        """
        args = ["-T4"]
        
        if service_detection:
            args.append("-sV")
        
        args.extend(["-p", ports])
        
        if scripts:
            args.extend(["--script", ",".join(scripts)])
        
        # Output as XML for parsing
        args.extend(["-oX", "-", target])
        
        result = await self._run_tool("nmap", args, timeout=timeout)
        
        # Parse XML output
        if result.success and result.output:
            result.parsed = self._parse_nmap_xml(result.output)
        
        return result
    
    def _parse_nmap_xml(self, xml_output: str) -> dict:
        """Parse nmap XML output."""
        try:
            import xml.etree.ElementTree as ET
            root = ET.fromstring(xml_output)
            
            hosts = []
            for host in root.findall("host"):
                host_data = {
                    "status": host.find("status").get("state") if host.find("status") is not None else "unknown",
                    "addresses": [],
                    "ports": [],
                    "hostnames": [],
                }
                
                # Parse addresses
                for addr in host.findall("address"):
                    host_data["addresses"].append({
                        "addr": addr.get("addr"),
                        "type": addr.get("addrtype"),
                    })
                
                # Parse hostnames
                hostnames = host.find("hostnames")
                if hostnames is not None:
                    for hostname in hostnames.findall("hostname"):
                        host_data["hostnames"].append(hostname.get("name"))
                
                # Parse ports
                ports = host.find("ports")
                if ports is not None:
                    for port in ports.findall("port"):
                        port_data = {
                            "port": int(port.get("portid")),
                            "protocol": port.get("protocol"),
                            "state": port.find("state").get("state") if port.find("state") is not None else "unknown",
                        }
                        
                        service = port.find("service")
                        if service is not None:
                            port_data["service"] = {
                                "name": service.get("name"),
                                "product": service.get("product"),
                                "version": service.get("version"),
                            }
                        
                        host_data["ports"].append(port_data)
                
                hosts.append(host_data)
            
            return {"hosts": hosts}
            
        except Exception as e:
            logger.error(f"Failed to parse nmap XML: {e}")
            return {}
    
    # =========================================================================
    # SUBFINDER - Subdomain Enumeration
    # =========================================================================
    
    async def subfinder_scan(
        self,
        domain: str,
        timeout: int = 120,
    ) -> ToolResult:
        """
        Enumerate subdomains for a domain.
        
        Args:
            domain: Target domain (e.g., example.com)
            timeout: Timeout in seconds
        """
        args = ["-d", domain, "-silent", "-json"]
        result = await self._run_tool("subfinder", args, timeout=timeout, parse_json=True)
        
        # Extract just the hosts
        if result.parsed and isinstance(result.parsed, list):
            result.parsed = {
                "subdomains": [item.get("host") for item in result.parsed if item.get("host")]
            }
        
        return result
    
    # =========================================================================
    # HTTPX - HTTP Probing
    # =========================================================================
    
    async def httpx_probe(
        self,
        targets: list[str],
        timeout: int = 120,
    ) -> ToolResult:
        """
        Probe HTTP endpoints for live hosts and tech stack.
        
        Args:
            targets: List of URLs or hosts to probe
            timeout: Timeout in seconds
        """
        # Create temp file with targets
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as f:
            f.write("\n".join(targets))
            targets_file = f.name
        
        try:
            args = [
                "-l", targets_file,
                "-silent",
                "-json",
                "-status-code",
                "-title",
                "-tech-detect",
                "-follow-redirects",
            ]
            result = await self._run_tool("httpx", args, timeout=timeout, parse_json=True)
            
            # Parse results
            if result.parsed and isinstance(result.parsed, list):
                result.parsed = {
                    "probes": [
                        {
                            "url": item.get("url"),
                            "status_code": item.get("status_code"),
                            "title": item.get("title"),
                            "technologies": item.get("tech", []),
                            "content_length": item.get("content_length"),
                        }
                        for item in result.parsed
                    ]
                }
            
            return result
        finally:
            os.unlink(targets_file)
    
    # =========================================================================
    # KATANA - Web Crawling
    # =========================================================================
    
    async def katana_crawl(
        self,
        target_url: str,
        depth: int = 2,
        timeout: int = 180,
    ) -> ToolResult:
        """
        Crawl a website for endpoints and parameters.
        
        Args:
            target_url: Starting URL
            depth: Crawl depth
            timeout: Timeout in seconds
        """
        args = [
            "-u", target_url,
            "-d", str(depth),
            "-silent",
            "-json",
            "-field", "url,path,method,param",
        ]
        result = await self._run_tool("katana", args, timeout=timeout, parse_json=True)
        
        # Parse results
        if result.parsed and isinstance(result.parsed, list):
            endpoints = []
            params = set()
            
            for item in result.parsed:
                endpoint = {
                    "url": item.get("request", {}).get("url") or item.get("url"),
                    "method": item.get("request", {}).get("method", "GET"),
                    "path": item.get("request", {}).get("path"),
                }
                endpoints.append(endpoint)
                
                # Extract parameters
                for param in item.get("parameters", []):
                    params.add(param)
            
            result.parsed = {
                "endpoints": endpoints,
                "parameters": list(params),
                "total_urls": len(endpoints),
            }
        
        return result
    
    # =========================================================================
    # FFUF - Web Fuzzing
    # =========================================================================
    
    async def ffuf_fuzz(
        self,
        target_url: str,
        wordlist: str,
        timeout: int = 300,
        filter_status: Optional[list[int]] = None,
    ) -> ToolResult:
        """
        Fuzz a URL for hidden paths/parameters.
        
        Args:
            target_url: URL with FUZZ keyword (e.g., https://example.com/FUZZ)
            wordlist: Path to wordlist file
            timeout: Timeout in seconds
            filter_status: Filter out these status codes
        """
        args = [
            "-u", target_url,
            "-w", wordlist,
            "-s",  # Silent
            "-json",
            "-mc", "all",  # Match all codes initially
        ]
        
        if filter_status:
            args.extend(["-fc", ",".join(str(s) for s in filter_status)])
        
        return await self._run_tool("ffuf", args, timeout=timeout, parse_json=True)
    
    # =========================================================================
    # SQLMAP - SQL Injection
    # =========================================================================
    
    async def sqlmap_test(
        self,
        target_url: str,
        data: Optional[str] = None,
        timeout: int = 300,
    ) -> ToolResult:
        """
        Test for SQL injection vulnerabilities.
        
        Args:
            target_url: Target URL with parameter
            data: POST data if applicable
            timeout: Timeout in seconds
        """
        args = [
            "-u", target_url,
            "--batch",  # Never ask for input
            "--level=1",
            "--risk=1",
            "--output-dir=/tmp/sqlmap",
        ]
        
        if data:
            args.extend(["--data", data])
        
        return await self._run_tool("sqlmap", args, timeout=timeout)
    
    # =========================================================================
    # PLAYWRIGHT - Browser Automation
    # =========================================================================
    
    async def browser_screenshot(
        self,
        url: str,
        output_path: str,
    ) -> ToolResult:
        """Take a screenshot of a webpage."""
        try:
            from playwright.async_api import async_playwright
            
            async with async_playwright() as p:
                browser = await p.chromium.launch(headless=True)
                page = await browser.new_page()
                await page.goto(url, wait_until="networkidle")
                await page.screenshot(path=output_path, full_page=True)
                await browser.close()
            
            return ToolResult(
                tool="playwright",
                success=True,
                output=f"Screenshot saved to {output_path}",
            )
        except Exception as e:
            return ToolResult(
                tool="playwright",
                success=False,
                error=str(e),
            )
    
    async def browser_get_forms(
        self,
        url: str,
    ) -> ToolResult:
        """Extract forms from a webpage."""
        try:
            from playwright.async_api import async_playwright
            
            async with async_playwright() as p:
                browser = await p.chromium.launch(headless=True)
                page = await browser.new_page()
                await page.goto(url, wait_until="domcontentloaded")
                
                # Extract forms
                forms = await page.evaluate("""
                    () => {
                        const forms = [];
                        document.querySelectorAll('form').forEach(form => {
                            const inputs = [];
                            form.querySelectorAll('input, textarea, select').forEach(input => {
                                inputs.push({
                                    name: input.name || input.id,
                                    type: input.type || input.tagName.toLowerCase(),
                                    value: input.value || '',
                                });
                            });
                            forms.push({
                                action: form.action || '',
                                method: form.method || 'GET',
                                inputs: inputs,
                            });
                        });
                        return forms;
                    }
                """)
                
                await browser.close()
            
            return ToolResult(
                tool="playwright",
                success=True,
                parsed={"forms": forms},
            )
        except Exception as e:
            return ToolResult(
                tool="playwright",
                success=False,
                error=str(e),
            )


# Global instance
_tools: Optional[SecurityTools] = None


def get_tools() -> SecurityTools:
    """Get the global SecurityTools instance."""
    global _tools
    if _tools is None:
        _tools = SecurityTools()
    return _tools
