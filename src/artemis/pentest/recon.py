"""
Reconnaissance Agent - Shannon-Inspired Attack Surface Mapping

Maps the application's attack surface through:
- Code analysis (whitebox)
- API endpoint enumeration
- Authentication flow analysis
- Input vector identification
- Authorization architecture mapping
"""

import asyncio
import json
import logging
import time
from pathlib import Path
from typing import Optional

from .agents import BaseAgent, AgentResult

logger = logging.getLogger("artemis.pentest.recon")


RECON_SYSTEM_PROMPT = """You are a world-class Reconnaissance Analyst and Attack Surface Mapper conducting a white-box security assessment.

Your mission is to create a comprehensive, structured map of the target application's attack surface. You are NOT looking for vulnerabilities yet - you are building the foundational intelligence that all vulnerability specialists will rely on.

Your analysis must detail:
1. Application components and technology stack
2. API endpoints with authentication requirements
3. Input vectors for each endpoint
4. Authentication and session management flows
5. Authorization architecture and role hierarchy
6. Potential injection sources and data flows

Focus on network-accessible attack surfaces only. Exclude local-only scripts, build tools, and development utilities.

Output your analysis as structured markdown with clear sections for:
- Executive Summary
- Technology Stack
- API Endpoint Inventory (with auth requirements)
- Authentication Flows
- Authorization Architecture
- Input Vectors
- Injection Sources
"""


class ReconAgent(BaseAgent):
    """
    Reconnaissance agent for attack surface mapping.
    
    Analyzes:
    - Pre-recon scan data (nmap, whatweb)
    - Source code structure
    - API endpoints and routes
    - Authentication mechanisms
    - Authorization controls
    """
    
    agent_name = "recon"
    agent_role = "Reconnaissance Analyst"
    
    def get_system_prompt(self) -> str:
        return RECON_SYSTEM_PROMPT
    
    async def run(self) -> AgentResult:
        """Execute reconnaissance analysis."""
        self.start_time = time.time()
        
        logger.info("Starting reconnaissance analysis")
        
        try:
            # Load pre-recon data
            pre_recon = self.read_deliverable("pre_recon_deliverable.md")
            
            # Build comprehensive analysis prompt
            prompt = self._build_recon_prompt(pre_recon)
            
            # Query LLM for analysis
            logger.info("Querying LLM for attack surface analysis...")
            response = await self.query_llm(prompt)
            
            # Parse structured data from response
            recon_data = self._parse_recon_response(response)
            
            # Write deliverable
            self.write_deliverable("recon_deliverable.md", response)
            
            # Generate API inventory JSON
            if recon_data.get("endpoints"):
                self._write_api_inventory(recon_data["endpoints"])
            
            duration_ms = int((time.time() - self.start_time) * 1000)
            
            return AgentResult(
                success=True,
                turns=self.turns,
                tokens_used=self.tokens_used,
                duration_ms=duration_ms,
                data=recon_data,
                deliverable_path=str(self.deliverables_dir / "recon_deliverable.md"),
            )
            
        except Exception as e:
            logger.error(f"Reconnaissance failed: {e}")
            return AgentResult(
                success=False,
                turns=self.turns,
                error=str(e),
            )
    
    def _build_recon_prompt(self, pre_recon: str) -> str:
        """Build the reconnaissance analysis prompt."""
        
        # Get code structure if available
        code_context = ""
        if self.config.repo_path:
            code_context = self._analyze_code_for_prompt()
        
        prompt = f"""Analyze the following target application and create a comprehensive attack surface map.

## Target Information
- **URL:** {self.config.target_url}
- **Repository:** {self.config.repo_path or "Not provided (blackbox assessment)"}

## Pre-Reconnaissance Data
{pre_recon}

## Source Code Analysis
{code_context if code_context else "No source code available - perform blackbox analysis based on external scans."}

## Required Output

Generate a detailed reconnaissance deliverable with the following sections:

### 1. Executive Summary
Brief overview of the application, technology stack, and primary attack surfaces.

### 2. Technology & Service Map
- Frontend framework and libraries
- Backend language and framework
- Database technology
- Infrastructure details
- Identified subdomains
- Open ports and services

### 3. API Endpoint Inventory
Create a table with ALL discovered endpoints:
| Method | Endpoint | Required Role | Parameters | Auth Mechanism | Description |
|--------|----------|---------------|------------|----------------|-------------|

For each endpoint, identify:
- HTTP method (GET, POST, PUT, DELETE, etc.)
- Required authentication/role (anon, user, admin, etc.)
- Input parameters (query, body, headers)
- Authorization mechanism (middleware, decorator, inline)

### 4. Authentication & Session Management
- Login endpoints and flows
- Session/token mechanisms
- Password reset flows
- 2FA/MFA if present
- Code pointers for auth logic

### 5. Authorization Architecture
- Role hierarchy (anon -> user -> admin -> superadmin)
- Permission model
- Role assignment process
- Privilege validation points
- Object ownership patterns

### 6. Input Vectors for Vulnerability Analysis
List all locations where user input is accepted:
- URL parameters
- POST body fields
- HTTP headers
- Cookie values
- File uploads
- WebSocket messages

### 7. Injection Source Candidates
For downstream vulnerability agents, identify potential injection points:
- SQL query construction points
- Command execution points
- File path handling
- Template rendering
- Deserialization points

Format code locations as: `file_path:line_number`

### 8. Network & Data Flow Map
Describe how data flows through the application, highlighting security boundaries.

Output your complete analysis in markdown format.
"""
        return prompt
    
    def _analyze_code_for_prompt(self) -> str:
        """Analyze source code and generate context for prompt."""
        repo_path = Path(self.config.repo_path)
        if not repo_path.exists():
            return ""
        
        context_parts = []
        
        # Find route/endpoint files
        route_patterns = [
            "**/routes/**/*.py", "**/routes/**/*.js", "**/routes/**/*.ts",
            "**/controllers/**/*.py", "**/controllers/**/*.js", "**/controllers/**/*.ts",
            "**/api/**/*.py", "**/api/**/*.js", "**/api/**/*.ts",
            "**/views/**/*.py",
            "**/*router*.py", "**/*router*.js", "**/*router*.ts",
        ]
        
        route_files = []
        for pattern in route_patterns:
            route_files.extend(repo_path.glob(pattern))
        
        if route_files:
            context_parts.append("### Route/Controller Files Found:")
            for f in route_files[:20]:  # Limit to 20 files
                rel_path = f.relative_to(repo_path)
                context_parts.append(f"- `{rel_path}`")
                
                # Include first 50 lines of route files
                try:
                    content = f.read_text()[:3000]
                    context_parts.append(f"```\n{content}\n```\n")
                except Exception:
                    pass
        
        # Find auth/middleware files
        auth_patterns = [
            "**/auth/**/*.py", "**/auth/**/*.js", "**/auth/**/*.ts",
            "**/middleware/**/*.py", "**/middleware/**/*.js", "**/middleware/**/*.ts",
            "**/*auth*.py", "**/*auth*.js", "**/*auth*.ts",
            "**/*guard*.py", "**/*guard*.ts",
        ]
        
        auth_files = []
        for pattern in auth_patterns:
            auth_files.extend(repo_path.glob(pattern))
        
        if auth_files:
            context_parts.append("\n### Authentication/Authorization Files Found:")
            for f in auth_files[:10]:
                rel_path = f.relative_to(repo_path)
                context_parts.append(f"- `{rel_path}`")
                
                try:
                    content = f.read_text()[:2000]
                    context_parts.append(f"```\n{content}\n```\n")
                except Exception:
                    pass
        
        # Find model/schema files
        model_patterns = [
            "**/models/**/*.py", "**/models/**/*.ts",
            "**/schemas/**/*.py", "**/schemas/**/*.ts",
            "**/entities/**/*.py", "**/entities/**/*.ts",
        ]
        
        model_files = []
        for pattern in model_patterns:
            model_files.extend(repo_path.glob(pattern))
        
        if model_files:
            context_parts.append("\n### Model/Schema Files Found:")
            for f in model_files[:10]:
                rel_path = f.relative_to(repo_path)
                context_parts.append(f"- `{rel_path}`")
        
        return "\n".join(context_parts)
    
    def _parse_recon_response(self, response: str) -> dict:
        """Parse structured data from recon response."""
        data = {
            "endpoints": [],
            "auth_flows": [],
            "roles": [],
            "input_vectors": [],
            "injection_sources": [],
        }
        
        # Parse API endpoints table
        import re
        table_match = re.search(
            r'\|\s*Method\s*\|\s*Endpoint.*?\n\|[-|\s]+\n((?:\|.*\n)*)',
            response,
            re.IGNORECASE
        )
        
        if table_match:
            for line in table_match.group(1).split('\n'):
                if line.strip() and '|' in line:
                    parts = [p.strip() for p in line.split('|')]
                    if len(parts) >= 5:
                        data["endpoints"].append({
                            "method": parts[1] if len(parts) > 1 else "",
                            "path": parts[2] if len(parts) > 2 else "",
                            "role": parts[3] if len(parts) > 3 else "",
                            "params": parts[4] if len(parts) > 4 else "",
                        })
        
        return data
    
    def _write_api_inventory(self, endpoints: list):
        """Write API inventory JSON."""
        path = self.deliverables_dir / "api_inventory.json"
        path.write_text(json.dumps({
            "endpoints": endpoints,
            "total": len(endpoints),
        }, indent=2))
